// focus-mode.js - Modo de enfoque ADHD para concentrarse en una sola misi√≥n
// Archivo principal simplificado - La l√≥gica est√° en m√≥dulos separados:
// - focus-utils.js: Validaciones y utilidades
// - focus-scheduled.js: L√≥gica de tareas programadas
// - focus-render.js: Funciones de renderizado
(function(App) {
    'use strict';

    // Estado privado del modo enfoque
    let _isActive = false;
    let _currentFocusTaskId = null;
    let _initialized = false;

    /**
     * Inicializa el modo de enfoque
     */
    function init() {
        try {
            // Crear elementos del DOM si no existen
            _createFocusModeElements();
            
            // Escuchar eventos
            _attachEventListeners();
            
            console.log('‚úÖ Focus Mode initialized');
        } catch (error) {
            console.error('‚ùå Error initializing Focus Mode:', error);
        }
    }

    /**
     * Crea los elementos del DOM necesarios
     */
    function _createFocusModeElements() {
        if (!document.getElementById('focusModeOverlay')) {
            const overlay = document.createElement('div');
            overlay.id = 'focusModeOverlay';
            overlay.className = 'focus-mode-overlay';
            document.body.appendChild(overlay);
        }

        if (!document.getElementById('focusModeContainer')) {
            const container = document.createElement('div');
            container.id = 'focusModeContainer';
            container.className = 'focus-mode-container';
            document.body.appendChild(container);
        }
    }

    /**
     * Adjunta event listeners
     */
    function _attachEventListeners() {
        const overlay = document.getElementById('focusModeOverlay');
        if (overlay) overlay.addEventListener('click', deactivate);

        if (App.events?.on) {
            App.events.on('taskCompleted', _handleTaskCompleted);
            App.events.on('todayTasksUpdated', _handleTasksUpdated);
        }
    }

    /**
     * Activa el modo de enfoque
     */
    function activate() {
        if (_isActive) return;

        const result = App.focusScheduled.getNextAvailableTask();
        
        // Si no hay ninguna tarea (ni disponible ni programada)
        if (!result.task && !result.nextScheduledTask) {
            const msg = 'No hay misiones pendientes para hoy. ¬°Buen trabajo! üéâ';
            App.events?.emit ? App.events.emit('shownotifyMessage', msg) : alert(msg);
            return;
        }

        _isActive = true;

        // Reanudar el intervalo del timer y ocultar badge del FAB
        if (App.focusTimer) {
            App.focusTimer.resumeInterval();
            App.focusTimer.removeFabBadge();
        }

        document.getElementById('focusModeOverlay')?.classList.add('active');
        document.getElementById('focusModeContainer')?.classList.add('active');
        document.body.classList.add('focus-mode-active');

        // Si hay una tarea disponible, mostrarla normalmente
        if (result.task) {
            _currentFocusTaskId = result.task.id;
            _renderFocusedMission(result.task);
        } else {
            // Si solo hay tareas programadas para el futuro, mostrar la siguiente con opciones
            _currentFocusTaskId = result.nextScheduledTask.id;
            _renderScheduledMission(result.nextScheduledTask, result.minutesUntilNext, result.hasOtherAvailableTasks);
        }
    }

    /**
     * Desactiva el modo de enfoque
     */
    function deactivate() {
        if (!_isActive) return;

        _isActive = false;
        _currentFocusTaskId = null;
        
        // Limpiar countdown si existe
        App.focusScheduled.stopScheduledCountdown();
        
        // Pausar el intervalo pero mantener el timer activo en segundo plano
        if (App.focusTimer) {
            App.focusTimer.pauseInterval();
            App.focusTimer.renderFabBadge(); // Mostrar badge en el FAB
        }

        document.getElementById('focusModeOverlay')?.classList.remove('active');
        document.getElementById('focusModeContainer')?.classList.remove('active');
        document.body.classList.remove('focus-mode-active');
    }

    /**
     * Toggle del modo de enfoque
     */
    function toggle() {
        if (!_initialized) {
            init();
            _initialized = true;
        }
        
        if (!App?.state) {
            alert('El sistema a√∫n no est√° listo. Por favor, espera un momento.');
            return;
        }
        
        _isActive ? deactivate() : activate();
    }

    /**
     * Verifica si una tarea est√° disponible para completar ahora
     * Una tarea est√° disponible si:
     * - No tiene hora programada
     * - Su hora programada ya pas√≥
     * - Faltan 15 minutos o menos para su hora programada
     */
    function _isTaskAvailableNow(task) {
        // Si no tiene hora programada, est√° disponible
        if (!task.scheduleTime || !task.scheduleTime.time) {
            return true;
        }

        try {
            const timeString = task.scheduleTime.time;
            
            // Validar formato
            if (typeof timeString !== 'string' || !timeString.includes(':')) {
                return true; // Si el formato es inv√°lido, considerarla disponible
            }

            // Parsear la hora programada (formato "HH:MM")
            const [hours, minutes] = timeString.split(':').map(Number);
            
            // Validar n√∫meros
            if (isNaN(hours) || isNaN(minutes)) {
                return true;
            }

            const now = new Date();
            const scheduledTime = new Date();
            scheduledTime.setHours(hours, minutes, 0, 0);

            // Calcular diferencia en minutos
            const diffMinutes = (scheduledTime - now) / (1000 * 60);

            // Disponible si ya pas√≥ la hora o faltan 15 minutos o menos
            return diffMinutes <= 15;
        } catch (error) {
            console.warn('Error parsing schedule time:', error);
            return true; // En caso de error, considerarla disponible
        }
    }

    /**
     * Calcula cu√°ntos minutos faltan para que una tarea est√© disponible
     */
    function _getMinutesUntilAvailable(task) {
        if (!task.scheduleTime || !task.scheduleTime.time) {
            return 0;
        }

        try {
            const timeString = task.scheduleTime.time;
            
            // Validar formato
            if (typeof timeString !== 'string' || !timeString.includes(':')) {
                return 0;
            }

            const [hours, minutes] = timeString.split(':').map(Number);
            
            // Validar n√∫meros
            if (isNaN(hours) || isNaN(minutes)) {
                return 0;
            }

            const now = new Date();
            const scheduledTime = new Date();
            scheduledTime.setHours(hours, minutes, 0, 0);

            const diffMinutes = Math.ceil((scheduledTime - now) / (1000 * 60));
            return Math.max(0, diffMinutes);
        } catch (error) {
            console.warn('Error calculating minutes until available:', error);
            return 0;
        }
    }

    /**
     * Obtiene la primera tarea incompleta disponible ahora (respetando el orden guardado)
     * PRIORIDAD: Tareas programadas para hora cercana > Tareas sin hora > Tareas programadas lejanas
     * Retorna un objeto con:
     * - task: la tarea disponible (o null si no hay)
     * - nextScheduledTask: la siguiente tarea programada si no hay disponibles
     * - minutesUntilNext: minutos hasta que est√© disponible la siguiente
     * - hasOtherAvailableTasks: si hay otras tareas disponibles despu√©s de la programada
     */
    function _getNextAvailableTask(skipTaskId = null) {
        const todayTasks = App.state.getTodayTasks();
        const incompleteTasks = todayTasks.filter(task => !task.completed);
        
        // Obtener el orden guardado
        const savedOrder = App.state.getTodayTaskOrder() || [];
        
        // Ordenar las tareas seg√∫n el orden guardado
        const orderedTasks = [];
        const remainingTasks = new Set(incompleteTasks.map(t => t.id));
        
        // Primero agregar las tareas en el orden guardado
        savedOrder.forEach(id => {
            const task = incompleteTasks.find(t => t.id === id);
            if (task) {
                orderedTasks.push(task);
                remainingTasks.delete(id);
            }
        });
        
        // Luego agregar las tareas que no est√°n en el orden guardado
        remainingTasks.forEach(id => {
            const task = incompleteTasks.find(t => t.id === id);
            if (task) orderedTasks.push(task);
        });
        
        // Filtrar la tarea a saltar si se especific√≥
        const tasksToConsider = skipTaskId 
            ? orderedTasks.filter(t => t.id !== skipTaskId)
            : orderedTasks;
        
        // PRIORIDAD 1: Buscar tareas programadas cercanas (‚â§15 min) o sin hora
        const availableTask = tasksToConsider.find(task => _isTaskAvailableNow(task));
        
        if (availableTask) {
            return { 
                task: availableTask, 
                nextScheduledTask: null, 
                minutesUntilNext: 0,
                hasOtherAvailableTasks: false
            };
        }
        
        // PRIORIDAD 2: Si no hay tareas disponibles, buscar la programada m√°s cercana
        // Ordenar por tiempo hasta disponibilidad (las m√°s cercanas primero)
        const scheduledTasks = tasksToConsider
            .filter(task => task.scheduleTime && task.scheduleTime.time)
            .map(task => ({
                task,
                minutesUntil: _getMinutesUntilAvailable(task)
            }))
            .sort((a, b) => a.minutesUntil - b.minutesUntil);
        
        // Si hay tareas programadas, tomar la m√°s cercana
        const nextScheduled = scheduledTasks.length > 0 ? scheduledTasks[0] : null;
        
        if (nextScheduled) {
            // Verificar si hay otras tareas disponibles (sin hora o con hora cercana)
            const hasOtherAvailableTasks = tasksToConsider.some(task => 
                task.id !== nextScheduled.task.id && _isTaskAvailableNow(task)
            );
            
            return { 
                task: null, 
                nextScheduledTask: nextScheduled.task, 
                minutesUntilNext: nextScheduled.minutesUntil,
                hasOtherAvailableTasks
            };
        }
        
        // PRIORIDAD 3: Si no hay tareas programadas, tomar la primera sin hora
        const taskWithoutSchedule = tasksToConsider.find(task => !task.scheduleTime || !task.scheduleTime.time);
        
        if (taskWithoutSchedule) {
            return { 
                task: taskWithoutSchedule, 
                nextScheduledTask: null, 
                minutesUntilNext: 0,
                hasOtherAvailableTasks: false
            };
        }
        
        // No hay tareas
        return { 
            task: null, 
            nextScheduledTask: null, 
            minutesUntilNext: 0,
            hasOtherAvailableTasks: false
        };
    }

    /**
     * Obtiene la primera tarea incompleta de hoy (respetando el orden guardado)
     * DEPRECATED: Usar _getNextAvailableTask() en su lugar
     */
    function _getFirstIncompleteTask() {
        const result = _getNextAvailableTask();
        return result.task || result.nextScheduledTask;
    }


    /**
     * Obtiene datos de la tarea para renderizar
     */
    function _getTaskData(task) {
        const state = App.state.get();
        const mission = task.missionId ? state.missions.find(m => m.id === task.missionId) : null;
        
        // Categor√≠a
        let categoryName = 'Sin prop√≥sito';
        const categoryId = task.categoryId || mission?.categoryId;
        if (categoryId) {
            const category = App.state.getCategoryById(categoryId);
            categoryName = category?.name || 'Sin prop√≥sito';
        }

        // Progreso
        const maxReps = task.dailyRepetitions?.max || 1;
        const currentReps = task.currentRepetitions || 0;
        const progressPercentage = (currentReps / maxReps) * 100;

        // Puntos (con bonus)
        const bonusMissionId = App.state.getBonusMissionForToday();
        const points = (task.missionId === bonusMissionId) ? task.points * 2 : task.points;

        return {
            categoryName,
            description: mission?.description || null,
            maxReps,
            currentReps,
            progressPercentage,
            points
        };
    }

    /**
     * Renderiza una misi√≥n programada para el futuro con opciones de esperar o iniciar
     */
    function _renderScheduledMission(task, minutesUntil, hasOtherTasks = false) {
        const container = document.getElementById('focusModeContainer');
        if (!container) return;

        const data = _getTaskData(task);
        const timeText = task.scheduleTime?.time || '';
        
        // Mensaje seg√∫n si hay otras tareas disponibles
        const waitMessage = hasOtherTasks 
            ? 'Esta misi√≥n est√° programada para m√°s tarde. Puedes iniciarla ahora o hacer otra misi√≥n mientras esperas.'
            : 'Esta misi√≥n est√° programada para m√°s tarde. Puedes iniciarla ahora o esperar hasta la hora programada.';
        
        container.innerHTML = `
            <div class="focus-mission-card scheduled-mission${!data.description ? ' no-description' : ''}">
                <div class="focus-header">
                    <div class="focus-mission-label">‚è∞ Misi√≥n Programada</div>
                </div>
                
                <button class="focus-close-btn" aria-label="Cerrar modo zen">√ó</button>
                
                <div class="focus-content-wrapper">
                    <div class="focus-main-section">
                        <h1 class="focus-title">${task.name}</h1>
                    </div>
                    
                    ${data.description ? `<div class="focus-description">${data.description}</div>` : ''}
                    
                    <div class="scheduled-message">
                        <span class="scheduled-message-icon">‚è±Ô∏è</span>
                        ${waitMessage}
                    </div>
                    
                    <div class="focus-scheduled-info">
                        <div class="scheduled-time-display">
                            <span class="scheduled-icon">‚è∞</span>
                            <span class="scheduled-time">${timeText}</span>
                        </div>
                        <div class="scheduled-countdown">
                            <span class="countdown-label">Comienza en</span>
                            <span class="countdown-value">${minutesUntil} min</span>
                        </div>
                    </div>
                    
                    <div class="focus-bottom-section">
                        <button class="focus-action-btn focus-start-early-btn" data-task-id="${task.id}">
                            <span class="focus-action-icon">‚ñ∂</span>
                            <span class="focus-action-text">Iniciar Ahora</span>
                            <span class="focus-action-points">+${data.points}</span>
                        </button>
                        
                        ${hasOtherTasks ? `
                        <button class="focus-action-btn focus-skip-btn" data-task-id="${task.id}">
                            <span class="focus-action-icon">‚è≠Ô∏è</span>
                            <span class="focus-action-text">Hacer Otra Misi√≥n</span>
                        </button>
                        ` : ''}
                    </div>
                </div>
                
                <div class="focus-footer">
                    <span class="focus-category">${data.categoryName}</span>
                </div>
            </div>
        `;

        // Adjuntar event listeners
        _attachScheduledMissionEventListeners(task.id, hasOtherTasks);
        
        // Iniciar countdown que actualiza cada minuto
        _startScheduledCountdown(task, minutesUntil);
    }

    /**
     * Inicia el countdown para una misi√≥n programada
     */
    let _countdownInterval = null;
    function _startScheduledCountdown(task, initialMinutes) {
        // Limpiar intervalo anterior si existe
        if (_countdownInterval) {
            clearInterval(_countdownInterval);
        }

        let minutesLeft = initialMinutes;
        
        _countdownInterval = setInterval(() => {
            minutesLeft--;
            
            const countdownValue = document.querySelector('.countdown-value');
            if (countdownValue) {
                countdownValue.textContent = `${minutesLeft} min`;
            }
            
            // Si lleg√≥ el momento, cambiar a modo normal
            if (minutesLeft <= 0) {
                clearInterval(_countdownInterval);
                _countdownInterval = null;
                
                // Renderizar la misi√≥n en modo normal
                if (_isActive && _currentFocusTaskId === task.id) {
                    _renderFocusedMission(task);
                }
            }
        }, 60000); // Actualizar cada minuto
    }

    /**
     * Adjunta event listeners a una misi√≥n programada
     */
    function _attachScheduledMissionEventListeners(taskId, hasOtherTasks) {
        const container = document.getElementById('focusModeContainer');
        
        // Bot√≥n "Iniciar Ahora"
        container?.querySelector('.focus-start-early-btn')?.addEventListener('click', () => {
            // Detener el countdown
            if (_countdownInterval) {
                clearInterval(_countdownInterval);
                _countdownInterval = null;
            }
            
            // Obtener la tarea y renderizarla en modo normal
            const task = App.state.getTodayTasks().find(t => t.id === taskId);
            if (task) {
                _renderFocusedMission(task);
            }
        });
        
        // Bot√≥n "Hacer Otra Misi√≥n" (solo si hay otras tareas disponibles)
        if (hasOtherTasks) {
            container?.querySelector('.focus-skip-btn')?.addEventListener('click', () => {
                // Detener el countdown
                if (_countdownInterval) {
                    clearInterval(_countdownInterval);
                    _countdownInterval = null;
                }
                
                // Buscar la siguiente tarea disponible saltando la actual
                const result = _getNextAvailableTask(taskId);
                
                if (result.task) {
                    // Hay otra tarea disponible, mostrarla
                    _currentFocusTaskId = result.task.id;
                    _renderFocusedMission(result.task);
                } else if (result.nextScheduledTask) {
                    // Solo hay m√°s tareas programadas
                    _currentFocusTaskId = result.nextScheduledTask.id;
                    _renderScheduledMission(result.nextScheduledTask, result.minutesUntilNext, result.hasOtherAvailableTasks);
                } else {
                    // No hay m√°s tareas
                    _renderEmptyState();
                }
            });
        }
        
        // Bot√≥n cerrar
        container?.querySelector('.focus-close-btn')?.addEventListener('click', () => {
            // Limpiar countdown al cerrar
            if (_countdownInterval) {
                clearInterval(_countdownInterval);
                _countdownInterval = null;
            }
            deactivate();
        });
    }

    /**
     * Renderiza la misi√≥n enfocada
     */
    function _renderFocusedMission(task) {
        const container = document.getElementById('focusModeContainer');
        if (!container) return;

        const data = _getTaskData(task);
        
        // Verificar si ya hay un timer activo para esta tarea
        let timerHTML = '';
        if (App.focusTimer && task.scheduleDuration) {
            const existingTimer = App.focusTimer.getTimerState(task.id);
            
            // Solo iniciar un nuevo timer si no existe uno activo para esta tarea
            if (!existingTimer) {
                App.focusTimer.startTimer(task);
            }
            
            timerHTML = App.focusTimer.renderTimer(container, task);
        }
        
        // Calcular puntos con bonus si aplica
        const displayPoints = App.focusTimer ? App.focusTimer.calculatePoints(task, data.points) : data.points;

        container.innerHTML = `
            <div class="focus-mission-card${!data.description ? ' no-description' : ''}">
                <div class="focus-header">
                    <div class="focus-mission-label">Misi√≥n Actual</div>
                </div>
                
                <button class="focus-close-btn" aria-label="Cerrar modo zen">√ó</button>
                
                <div class="focus-content-wrapper">
                    <div class="focus-main-section">
                        <h1 class="focus-title">${task.name}</h1>
                    </div>
                    
                    ${data.description ? `<div class="focus-description">${data.description}</div>` : ''}
                    
                    ${data.maxReps > 1 ? `
                    <div class="focus-progress">
                        <div class="focus-progress-label">
                            <span>Repeticiones</span>
                            <span class="focus-progress-text">${data.currentReps} / ${data.maxReps}</span>
                        </div>
                        <div class="focus-progress-bar">
                            <div class="focus-progress-fill" style="width: ${data.progressPercentage}%"></div>
                        </div>
                    </div>` : ''}
                    
                    ${timerHTML}
                    
                    <div class="focus-bottom-section">
                        <button class="focus-action-btn" data-task-id="${task.id}">
                            <span class="focus-action-icon">‚úì</span>
                            <span class="focus-action-text">Completar</span>
                            <span class="focus-action-points">+${displayPoints}</span>
                        </button>
                    </div>
                </div>
                
                <div class="focus-footer">
                    <span class="focus-category">${data.categoryName}</span>
                </div>
            </div>
        `;

        // Adjuntar event listeners
        _attachMissionEventListeners(task.id);
    }

    /**
     * Adjunta event listeners a la misi√≥n renderizada
     */
    function _attachMissionEventListeners(taskId) {
        const container = document.getElementById('focusModeContainer');
        container?.querySelector('.focus-action-btn')?.addEventListener('click', () => _handleCompleteClick(taskId));
        container?.querySelector('.focus-close-btn')?.addEventListener('click', deactivate);
    }

    /**
     * Renderiza el estado vac√≠o (sin misiones)
     */
    function _renderEmptyState() {
        const container = document.getElementById('focusModeContainer');
        if (!container) return;

        container.innerHTML = `
            <div class="focus-mission-card no-description">
                <div class="focus-header">
                    <div class="focus-mission-label">Misi√≥n Actual</div>
                </div>
                
                <button class="focus-close-btn" aria-label="Cerrar modo zen">√ó</button>
                
                <div class="focus-content-wrapper">
                    <div class="focus-main-section">
                        <div class="focus-empty-icon">üéâ</div>
                        <h1 class="focus-title">¬°Todo Completado!</h1>
                        <p class="focus-empty-message">
                            No tienes misiones pendientes para hoy.<br>
                            ¬°Excelente trabajo! Disfruta tu tiempo libre.
                        </p>
                    </div>
                    
                    <div class="focus-bottom-section">
                        <button class="focus-action-btn focus-exit-btn">
                            <span class="focus-action-icon">üö™</span>
                            <span class="focus-action-text">Salir del Modo Zen</span>
                        </button>
                    </div>
                </div>
                
                <div class="focus-footer">
                    <span class="focus-category">Todas las misiones completadas</span>
                </div>
            </div>
        `;

        container.querySelector('.focus-close-btn')?.addEventListener('click', deactivate);
        container.querySelector('.focus-exit-btn')?.addEventListener('click', deactivate);
    }

    /**
     * Muestra celebraci√≥n al completar
     */
    function _showCelebration() {
        const celebration = document.createElement('div');
        celebration.className = 'focus-celebration';
        celebration.innerHTML = `
            <div class="focus-celebration-icon">‚ú®</div>
            <div class="focus-celebration-text">¬°Completado!</div>
        `;
        document.body.appendChild(celebration);

        // Crear confetti usando clases CSS
        const confettiClasses = ['confetti-green', 'confetti-purple', 'confetti-pink', 'confetti-light'];
        for (let i = 0; i < 30; i++) {
            setTimeout(() => {
                const confetti = document.createElement('div');
                const colorClass = confettiClasses[Math.floor(Math.random() * confettiClasses.length)];
                confetti.className = `focus-confetti ${colorClass}`;
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.animationDuration = (Math.random() * 0.5 + 1) + 's';
                document.body.appendChild(confetti);

                setTimeout(() => confetti.remove(), 1500);
            }, i * 30);
        }

        setTimeout(() => celebration.remove(), 800);
    }

    /**
     * Anima la barra de progreso
     */
    function _animateProgressBar(taskId) {
        const progressBar = document.querySelector('.focus-progress-fill');
        const progressText = document.querySelector('.focus-progress-text');
        
        if (!progressBar || !progressText) return;

        // Obtener la tarea actualizada
        const task = App.state.getTodayTasks().find(t => t.id === taskId);
        if (!task) return;

        const maxReps = task.dailyRepetitions?.max || 1;
        const currentReps = task.currentRepetitions || 0;
        const newPercentage = (currentReps / maxReps) * 100;

        // Animar la barra (el CSS maneja la transici√≥n)
        progressBar.style.width = newPercentage + '%';
        progressText.textContent = `${currentReps} / ${maxReps}`;
    }

    /**
     * Maneja el click en el bot√≥n de completar
     */
    function _handleCompleteClick(taskId) {
        const btn = document.querySelector('.focus-action-btn');
        if (btn) {
            btn.classList.add('completing');
        }

        // Obtener la tarea antes de completarla para calcular bonus
        const todayTasks = App.state.getTodayTasks();
        const task = todayTasks.find(t => t.id === taskId);
        
        // Calcular puntos con bonus si aplica
        let bonusPoints = 0;
        if (App.focusTimer && task) {
            const hasBonus = App.focusTimer.hasBonusActive(taskId);
            if (hasBonus) {
                bonusPoints = task.points; // El bonus es x2, as√≠ que sumamos los puntos base extra
                console.log(`üéØ Bonus x2 aplicado! +${bonusPoints} puntos extra`);
            }
        }

        // Completar la tarea
        const success = App.state.completeTaskRepetition(taskId);

        if (success) {
            // Agregar puntos bonus si aplica
            if (bonusPoints > 0) {
                App.state.addPoints(bonusPoints, { silentUI: false });
                App.events.emit('shownotifyMessage', `‚ö° ¬°BONUS x2! +${bonusPoints} puntos extra por completar a tiempo`);
            }
            
            // Verificar si la tarea tiene repeticiones
            const hasMoreReps = task && task.dailyRepetitions && task.dailyRepetitions.max > 1;
            const currentReps = task ? (task.currentRepetitions || 0) : 0;
            const maxReps = task ? (task.dailyRepetitions?.max || 1) : 1;
            const stillHasReps = hasMoreReps && currentReps < maxReps;
            
            if (stillHasReps) {
                // Si a√∫n quedan repeticiones, reiniciar el timer
                if (App.focusTimer && task.scheduleDuration) {
                    App.focusTimer.stopTimer(); // Detener el timer actual
                    
                    // Peque√±o delay para asegurar que el DOM se actualice
                    setTimeout(() => {
                        App.focusTimer.startTimer(task); // Reiniciar para la siguiente repetici√≥n
                        
                        // Forzar actualizaci√≥n del display para restaurar estado activo
                        setTimeout(() => {
                            App.focusTimer.updateTimerDisplay(task.id);
                        }, 100);
                    }, 100);
                }
                
                _animateProgressBar(taskId);
                _showCelebration();
                
                // Quitar clase completing del bot√≥n
                setTimeout(() => {
                    if (btn) btn.classList.remove('completing');
                }, 600);
                
                return; // No avanzar a la siguiente misi√≥n
            } else {
                // No hay m√°s repeticiones, detener el timer completamente
                if (App.focusTimer) {
                    App.focusTimer.stopTimer();
                }
            }
            
            // Si no hay m√°s repeticiones o la tarea est√° completa, mostrar celebraci√≥n y avanzar
            _showCelebration();
            
            setTimeout(() => {
                // Verificar si hay m√°s tareas disponibles
                const result = _getNextAvailableTask();
                
                if (result.task) {
                    // Hay una tarea disponible, renderizarla normalmente
                    _currentFocusTaskId = result.task.id;
                    _renderFocusedMission(result.task);
                } else if (result.nextScheduledTask) {
                    // Solo hay tareas programadas, mostrar la siguiente con opciones
                    _currentFocusTaskId = result.nextScheduledTask.id;
                    _renderScheduledMission(result.nextScheduledTask, result.minutesUntilNext, result.hasOtherAvailableTasks);
                } else {
                    // No hay m√°s misiones, mostrar estado vac√≠o
                    _renderEmptyState();
                }
            }, 800);
        }
    }


    /**
     * Maneja cuando se actualizan las tareas
     */
    function _handleTasksUpdated() {
        if (!_isActive) return;

        // Verificar si hay tareas disponibles
        const result = _getNextAvailableTask();
        
        if (!result.task && !result.nextScheduledTask) {
            // No hay m√°s tareas, mostrar estado vac√≠o
            _renderEmptyState();
        } else if (result.task && result.task.id !== _currentFocusTaskId) {
            // Hay una tarea disponible diferente, actualizar
            _currentFocusTaskId = result.task.id;
            _renderFocusedMission(result.task);
        } else if (!result.task && result.nextScheduledTask) {
            // Solo hay tareas programadas
            if (result.nextScheduledTask.id !== _currentFocusTaskId) {
                _currentFocusTaskId = result.nextScheduledTask.id;
                _renderScheduledMission(result.nextScheduledTask, result.minutesUntilNext, result.hasOtherAvailableTasks);
            }
        }
    }

    // Exponer API p√∫blica
    App.focusMode = {
        init: init,
        activate: activate,
        deactivate: deactivate,
        toggle: toggle,
        isActive: () => _isActive
    };

    // Delegaci√≥n de eventos para el bot√≥n de toggle
    document.addEventListener('click', function(e) {
        if (e.target && e.target.id === 'focusModeToggleBtn') {
            e.preventDefault();
            e.stopPropagation();
            toggle();
        } else if (e.target && e.target.closest('#focusModeToggleBtn')) {
            e.preventDefault();
            e.stopPropagation();
            toggle();
        }
    }, true); // Usar capture phase para capturar antes que otros handlers

})(window.App = window.App || {});
